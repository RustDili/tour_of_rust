- title: Bölüm 7 - Nesne Yönelimli Programlama
  content_markdown: >
    Onlarca yıldır kullanılan C Programlama dilinde olduğu gibi, fikirleri işlevlerle ifade etmek, veriler ve program davranışını 
    temsil etmenin kanıtlanmış bir yoludur. Ancak zaman içinde bilgisayar bilimi, veri toplama ve soyutlamaya izin veren başka 
    programlama paradigmalarından da yararlanmıştır.
    
    Diğer programlama dillerinden geliyorsanız, bu programlama paradigmalarından biri olan nesne yönelimli programlamaya, yani **OOP**'a 
    aşina olabilirsiniz. 
    
    Bu bölümde Rust programlama dilini, işlevlerin ötesinde bir programlama dili olarak yeniden keşfedeceğiz.
- title: Nesne Yönelimli Programlama Nedir?
  content_markdown: >
    Nesne yönelimli programlama aşağıda kabaca özetlenen, bir dizi ikonik özelliğe sahip programlama dillerini ifade eder:

    * Kapsülleme  - Veri ve işlevleri, tek bir türden oluşan ve **nesne** adı verilen kavramsal birimle ilişkilendirebilmek.

    * Soyutlama - Bir nesnenin uygulama ayrıntılarını gizlemek için veri ve üye işlevlerini saklayabilmek.

    * Çok biçimlilik - Bir nesneyle farklı işlevsel perspektiflerden etkileşim kurma yeteneği.

    * Kalıtım - Diğer nesnelerin veri ve davranışlarını devralma yeteneği.
- title: Rust Bir Nesne Yönelimli Programlama Dili Değildir
  content_markdown: >
    Rust, veri ve davranışları anlamlı olacak şekilde miras alma yeteneğinden yoksundur.


    * Yapılar **alanlarını** bir üst yapıdan kalıtım yoluyla devralamazlar.

    * Yapılar **işlevlerini** bir üst yapıdan kalıtım yoluyla edinemezler.


    Ancak Rust, bu eksiklikleri giderecek pek çok özellik sunduğundan, kalıtımın yokluğunu hissetmeyeceksiniz.
- title: Metotlarla Kapsülleme
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=900c806a5b91969e8ae862e94aedc94a
  content_markdown: >
    Rust, **metot** veya **yöntem** olarak adlandırabileceğimiz, belirli işlevlerle ilişkilendirilmiş bir veri yapısı olan **nesne** kavramını destekler.


    Herhangi bir metodun ilk parametresi, `nesne_ornegi.metot()` söz dizimindeki gibi, o metoda yapılan çağrı ile ilişkili olan, **örneğin kendisini** 
    referans almalıdır. Bu ilk parametre için Rust aşağıdaki referans türlerini kullanmaktadır:

    * `&self` - Örnek için değişmez bir referans.

    * `&mut self` - Örnek için değişken bir referans.


    Metotlar, `impl` anahtar kelimesiyle başlayan bir uygulama bloğunda tanımlanır:

    ```rust

    impl BirYapi { 
        ...
        fn ornekle(&self) {
            ...
        }
    }

    ```
- title: Farklı Görünürlük Seviyelerindeki Soyutlamalar
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=403679578ea7c5d804cfc749a80e97ba
  content_markdown: >
    Rust, nesnelerin iç işleyişi ve yapılarını gizleyebilir.


    Halihazırda yapı tarafından bildirilen tüm alan ve metodlara, yalnızca ait oldukları modül tarafından erişilebileceği varsayılır.


    Yapı alan ve metodlarının modül dışından erişilebilir olması için `pub` anahtar sözcüğü kullanılır.
- title: Polymorphism With Traits
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A
  content_markdown: >
    Rust supports polymorphism with traits. Traits allow us to associate a set
    of methods with a struct type. 


    We first define the signatures of methods of a trait within:


    ```

    trait MyTrait {
        fn foo(&self);
        ...
    }

    ```


    When a struct implements a trait, it establishes a contract that allows us
    to indirectly interact with the struct 

    through the trait type (e.g. `&dyn MyTrait`) without having to know the real
    type.


    A struct's implemented traits methods are defined within an implementation
    block:


    ```rust

    impl MyTrait for MyStruct { 
        fn foo(&self) {
            ...
        }
        ... 
    }

    ```
- title: Implemented Methods On Traits
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%20%20%20%20%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
  content_markdown: >
    Traits can have implemented methods.


    The functions have no direct access to the inner fields of a struct, but it
    can 

    be useful for sharing behavior between many trait implementors.
- title: Trait Inheritance
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Atrait%20LoudNoiseMaker%3A%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20LoudNoiseMaker%20for%20SeaCreature%20%7B%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
  content_markdown: |
    Traits can inherit methods from other traits.
- title: Dynamic vs Static Dispatch
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20static_make_noise(creature%3A%20%26SeaCreature)%20%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20dynamic_make_noise(noise_maker%3A%20%26dyn%20NoiseMaker)%20%7B%0A%20%20%20%20%2F%2F%20we%20don't%20know%20the%20real%20type%0A%20%20%20%20noise_maker.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20static_make_noise(%26creature)%3B%0A%20%20%20%20dynamic_make_noise(%26creature)%3B%0A%7D%0A
  content_markdown: >
    Methods are executed in two ways:

    * static dispatch - When the instance type is known, we have direct
    knowledge of what function to call.

    * dynamic dispatch - When an instance type is not known, we must find out
    some way of calling the correct function.


    Trait types `&dyn MyTrait` give us the ability to work with instances of
    objects indirectly using dynamic dispatch.


    When dynamic dispatch is used, Rust will encourage you to put `dyn` before
    your trait type so people are aware.


    Memory details:

    * Dynamic dispatch is slightly slower because of the pointer chasing to find
    the real function call.
- title: Trait Objects
  content_markdown: >
    When we pass an instance of an object to a parameter of type `&dyn MyTrait`
    we pass what is called a *trait object*. 


    A trait object is what allows us to indirectly call the correct methods of
    an instance. A trait object is a struct that holds the pointer of 

    our instance with a list of function pointers to our instance's methods.


    Memory details:

    * This list of functions is known in C++ as a *vtable*.
- title: Handling Unsized Data
  content_markdown: >
    Traits introduce an interesting challenge when we want to store them within
    another struct. Traits obfuscate the original

    struct thus it also obfuscates the original size. Unsized values being
    stored in structs are handled in two ways in Rust:


    * `generics` - Using parameterized types effectively create struct/functions
    known types and thus known sizes.

    * `indirection` - Putting instances on the heap gives us a level of
    indirection that allow us to not have to worry about the size of the actual
    type and just store a pointer to it. There are other ways as well!
- title: Generic Functions
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise%3CT%3E(creature%3A%20%26T)%0Awhere%0A%20%20%20%20T%3A%20NoiseMaker%2C%0A%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%20at%20compile-time%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
  content_markdown: >
    Generics in Rust work hand in hand with traits. When we describe a
    parameterized type `T` we can constrain what types 

    can be used as an argument by listing what required traits the argument must
    implement.


    In this example type `T` must implement trait `Foo`:

    ```rust

    fn my_function<T>(foo: T)

    where
        T:Foo
    {
        ...
    }

    ```


    By using generics we create static typed functions at compile time that will
    have known types and sizes, allowing us to

    perform static dispatch and store as a sized value.
- title: Generic Function Shorthand
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise(creature%3A%20%26impl%20NoiseMaker)%0A%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%20at%20compile-time%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
  content_markdown: |
    Rust has a shorthand for expressing generics constrained by a trait:

    ```rust
    fn my_function(foo: impl Foo) {
        ...
    }
    ```

    This is equivalent to writing:

    ```rust
    fn my_function<T>(foo: T)
    where
        T:Foo
    {
        ...
    }
    ```
- title: Box
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Ocean%20%7B%0A%20%20%20%20animals%3A%20Vec%3CBox%3Cdyn%20NoiseMaker%3E%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22swish%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20ocean%20%3D%20Ocean%20%7B%0A%20%20%20%20%20%20%20%20animals%3A%20vec!%5BBox%3A%3Anew(ferris)%2C%20Box%3A%3Anew(sarah)%5D%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20for%20a%20in%20ocean.animals.iter()%20%7B%0A%20%20%20%20%20%20%20%20a.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A
  content_markdown: >
    `Box` is a data structure that allows us to move our data from the stack to
    the heap.


    `Box` is a struct known as a *smart pointer* that holds the pointer to our
    data on the heap.


    Because `Box` is a struct with a known size (because it just holds a
    pointer), it is 

    often used as a way to store a reference to something in a struct that must
    know the size 

    of its fields.


    `Box` is so common it can be used from anywhere:


    ```rust

    Box::new(Foo { ... })

    ```
- title: Generic Structs Revisited
  content_markdown: >
    Generic structs can also have their parameterized types constrained by
    traits.


    ```rust

    struct MyStruct<T>

    where
        T: MyTrait
    {
        foo: T
        ...
    }

    ```


    Generic structs have their parameterized type in their implementation
    blocks:


    ```rust

    impl<T> MyStruct<T> {
        ...
    }

    ```
- title: Chapter 7 - Conclusion
  content_markdown: >
    We now have more language features at hand to represent our ideas clearly! 

    Rust abstractions might be simple but they are powerful enough to make

    working with code a joy. In this chapter, we caught a glimpse of smart
    pointers

    with `Box`. In the next chapter we'll learn about how smart pointers can
    help us with other

    specialized memory situations.


    Resources:

    * [Video - Object-oriented Programming in 7
    minutes](https://www.youtube.com/watch?v=pTB0EiLXUC8)

    * [Article - "The faster you unlearn OOP, the better for you and your
    software"](https://dpc.pw/the-faster-you-unlearn-oop-the-better-for-you-and-your-software)
