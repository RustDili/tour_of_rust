- title: Bölüm 9 - Proje Organizasyonu ve Yapısı
  content_markdown: >
    Şu ana dek tüm kod örneklerimiz tek bir dosyadan oluşmaktaydı. Artık kodlarımızı organize ederek başkalarının kullanımına nasıl 
    sunabileceğimizi konuşma zamanının geldiğini hissediyorum.
- title: Modüller
  content_markdown: |
    Her Rust programı veya kütüphanesi birer **sandık**tır.

    Her sandık bir **modül** hiyerarşisinden oluşur.

    Her sandıkta bir kök modül bulunur.

    Her modül evrensel değişkenler, işlevler, yapılar, özellikler hatta başka modüllerden bile oluşabilir!

    Rust'ta ağaç benzeri hiyerarşik modül yapısına 1 e 1 dosya eşlemesi bulunmadığından, modül ağacının kod içinde, açıkça ve bizim tarafımızdan 
    oluşturulması gerekir.
- title: Bir Program Yazmak
  content_markdown: |
    Her program `main.rs` adlı dosyadan oluşan bir kök modüle sahiptir.
- title: Bir Kütüphane Yazmak
  content_markdown: |
    Her kütüphane `lib.rs` adlı dosyadan oluşan bir kök modüle sahiptir.
- title: Başka Modül ve Sandıklara Referans Vermek
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d8492f3cd0f1a16c2a01278de8c10537
  content_markdown: >
    Modül öğelerine `std::f64::consts::PI` şeklinde, modül içi tam yolun gösterilmesi ile başvuru yapılabilir.


    `use` anahtar sözcüğü daha basit bir yöntemdir. Bu sözcüğün kullanımı kod boyunca kullanılacak modül öğelerine tam yollarını belirtmeden 
    ulaşma olanağı sunar. Örneğin `use std::f64::consts::PI` şeklinde bir yol bildirmek, main işlevi içinde yalnızca `PI` tanımlayıcısını kullanmamıza izin verir.


    Standart kütüphanemiz **std**, işletim sisteminizle etkileşimde bulunabilmemiz için yararlı veri yapıları ve işlevlerden oluşan bir Rust sandığıdır.


    Topluluk tarafından oluşturulan sandıklara [https://crates.io](https://crates.io/) üzerindeki dizinden ulaşabilirsiniz.
- title: Çok Sayıda Öğeye Başvurmak
  content_markdown: |
    Aşağıda örneklendiği şekilde tek bir modül yolunda çok sayıda öğeye referans verilebilir.

    ```rust
    use std::f64::consts::{PI,TAU}
    ```

    Ferris TAU yiyemez, o sadece PI yemeyi tercih eder. 
- title: Modüller Oluşturmak
  content_markdown: |
    Bir programı hakkında düşündüğünüzde, çoğu zaman gözlerinizin önüne  dizinler halinde düzenlenmiş dosya hiyerarşisinden oluşan bir yapı geliyordur. 
    Rust, dosya yapınızla çok benzeşen modüller oluşturmanıza olanak sağlar. 

    Rust'ta bir modül bildirmenin iki yolu vardır. Örnek bir modül olan `turler` modülü, aşağıdaki iki yoldan biriyle oluşturulabilir:
      * `turler.rs` adındaki bir dosya oluşturarak.
      * içinde `mod.rs` dosyası bulunan `turler` adlı bir dizin biçiminde.
- title: Modül Hiyerarşisi
  content_markdown: >
    Bir modül bir başka modüle bağlı olduğunda, modül ile alt modülü arasında bir ilişki kurabilmesi için, alt modülün üst modülde bildirilmesi gerekir:


    ```rust

    mod turler;

    ```


    Yukarıdaki bildirim, `turler.rs` veya `turler/mod.rs` adlı bir dosyayı çağıracak ve içeriğini mevcut kapsamda yer alan `turler` adlı modüle ekleyecektir.
- title: Satır İçi Modül
  content_markdown: >
    Bir alt modül, üst modülün kodu içine doğrudan yerleştirilebilir.


    Satır içi modüller en çok birim testleri oluştururken kullanılırlar. Aşağıdaki kodda sadece test amaçlı kullanıldığında var olabilen 
    çevrim içi bir modül örneklenmektedir.


    ```

    // Aşağıdaki satır içi modül, bu makro tarafından, 

    // Rust test modunda kullanılmadığında kaldırılacaktır!

    #[cfg(test)]

    mod testler {
        // Üst modüle hemen erişemeyeceğimizden
        // daha açık davranmamamız gerekir.
        use super::*;

        ... testler başlasın ...
    }

    ```
- title: Yerleşik Modüllere Başvurmak
  content_markdown: >
    Rust, dilediğimiz modüle hemen erişebilmemiz için `use` eşliğinde kullanabileceğiniz birkaç anahtar kelime sunar.
      
    * `crate` - sandığınızın kök modülü.

    * `super` - mevcut modülününüzün üst modülü

    * `self` - mevcut modülünüz.
- title: Dışa Aktarmak
  content_markdown: >
    Varsayılan olarak, bir modülün üyelerine modülün dışından erişilemez. Bu kısıtlama alt modüller için de geçerli olduğundan modüllerin erişilir 
    olabilmesi için `pub` anahtar kelimesiyle belirtilmeleri gerekir.


    Benzer şekilde, bir sandık üyelerine sandık dışından da erişilemeyeceği varsayılır. O nedenle bir sandığın üyelerini dışarıdan erişime açmak 
    istiyorsanız, her bir üyenin, sandığın kök modülü olan `lib.rs` veya `main.rs` içinde `pub` anahtar sözcüğü ile bildirilmesi gerekir.
- title: Yapısal Görünürlük
  content_markdown: >
    İşlevlerde olduğu gibi yapı alanlarının dışarıya açılabilmesi için `pub` anahtar kelimesiyle belirtilmeleri gerekir.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5ea5dd58c287602ceb4a1e4b7d7c018a
- title: Ön Yükleme Modülü
  content_markdown: |
    You might be wondering how we have access to `Vec` or `Box`
    everywhere without a `use` to import them. It is because of the module
    `prelude` in the standard library.

    Know that in the Rust standard library anything that is exported in
    `std::prelude::*` is automatically available to every part of Rust.
    That is the case for `Vec` and `Box` but others as well (Option, Copy,
    etc.).
- title: Your Own Prelude
  content_markdown: >
    Because of standard library's prelude, it's common for your libary to have
    its own prelude module as a starting point for 

    where users should import all of the most common data structures for using
    your library (e.g `use my_library::prelude::*`).

    It doesn't automatically get used in programs/libraries that use your crate,
    but it's a good convention to follow so people

    know where to start.


    Ferris says, "Be a good rustacean and help a fellow crab out with a good
    prelude!"
- title: Chapter 9 - Conclusion
  content_markdown: >
    You now have a few tricks up your sleeve when it comes to creating Rust
    applications and libraries ready for the world. Don't

    worry about remembering it all. As your library grows and is used by other
    people, you'll find what works best at each milestone.


    Resources:

    - [Guidelines For Writing Rust
    APIs](https://rust-lang.github.io/api-guidelines/)
